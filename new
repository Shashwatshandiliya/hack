from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import sqlite3
from docx import Document
import requests
import json
import re

# === Configuration ===
API_URL    = "https://hackathon.scaifactory.dev.azure.scbdev.net/v1/chat/completions"
API_TOKEN  = "aaaaaaa"
DOC_PATH   = "C:/Users/2013309/Hackathon2.0/Backend/mini_summary.docx"

# === FastAPI App & CORS ===
app = FastAPI()

# 🛡️ CORS middleware MUST come before your routes:
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # your React dev server
    allow_credentials=True,
    allow_methods=["*"],                       # allows OPTIONS, POST, etc.
    allow_headers=["*"],                       # allows Content-Type, Accept, etc.
)

# === In‑Memory SQLite DB ===
db_conn = sqlite3.connect(":memory:", check_same_thread=False)

def setup_mock_db():
    cur = db_conn.cursor()
    cur.executescript("""
    CREATE TABLE PAYMENT_REQUEST (
        TXN_ID TEXT PRIMARY KEY,
        REQUEST_TIMESTAMP TEXT,
        AMOUNT REAL
    );
    CREATE TABLE PAYMENT_LEDGER (
        TXN_ID TEXT PRIMARY KEY,
        AMOUNT REAL,
        STATUS TEXT
    );
    CREATE TABLE REFUND_LEDGER (
        REFUND_ID TEXT PRIMARY KEY,
        ORDER_ID TEXT,
        AMOUNT REAL
    );
    CREATE TABLE PAYMENT_CONFIRMATION (
        TXN_ID TEXT PRIMARY KEY,
        STATUS TEXT,
        GATEWAY_NAME TEXT,
        GATEWAY_RESPONSE_TIME INTEGER
    );

    INSERT INTO PAYMENT_REQUEST VALUES ('TXN_8791234', '2025-07-02 10:00:00', 1200.50);
    INSERT INTO PAYMENT_LEDGER VALUES ('TXN_123', 1000.00, 'FAILED');
    INSERT INTO REFUND_LEDGER VALUES ('RFND_1', 'ORD_564392', 500.00);
    INSERT INTO REFUND_LEDGER VALUES ('RFND_2', 'ORD_564392', 500.00);
    INSERT INTO PAYMENT_CONFIRMATION VALUES ('TXN_998822', 'TIMEOUT', 'FastPay', 31000);
    """)
    db_conn.commit()

# === Read Word Document for Context ===
def read_word_doc(filepath: str) -> str:
    doc = Document(filepath)
    return "\n".join([para.text for para in doc.paragraphs]).strip()

# Startup: set up DB and load context
setup_mock_db()
context = read_word_doc(DOC_PATH)

# === LLM Remediation Call ===
def ask_llm_for_remediation(question: str, context: str) -> dict:
    messages = [{
        "role": "user",
        "content": f"""
You are a system assistant for resolving database issues in a financial application.

Based on the logs and previous incidents below, generate a SQL query to resolve the reported issue.

Respond in JSON format:
{{
  "sql_query": "<SQL to run - make it as generic as possible>",
  "confidence": <float from 0.0 to 1.0>,
  "reason": "<why you're confident>"
}}

Context:
{context}

Question:
{question}
        """
    }]

    headers = {
        "Authorization": f"Bearer {API_TOKEN}",
        "Content-Type": "application/json"
    }
    payload = {
        "model": "claude-3-7-sonnet",
        "messages": messages
    }

    resp = requests.post(API_URL, headers=headers, json=payload, verify=False)
    if resp.status_code == 200:
        content = resp.json()["choices"][0]["message"]["content"]
        try:
            json_str = re.search(r"\{.*\}", content, re.DOTALL).group()
            return json.loads(json_str)
        except Exception:
            return {"error": "Failed to parse JSON", "raw": content}
    return {"error": f"LLM API {resp.status_code}", "details": resp.text}

# === Pydantic Models ===
class IncidentRequest(BaseModel):
    incident_type: str
    order_id:    str = ""
    prompt:      str

class SQLRequest(BaseModel):
    sql: str

# === API Routes ===
@app.post("/auto-remediate")
def auto_remediate(req: IncidentRequest):
    # Build the full question for the LLM
    if req.incident_type.lower() == "duplicate refund":
        full_q = f"There are duplicate refunds for ORDER_ID {req.order_id}. {req.prompt}"
    else:
        full_q = req.prompt

    result = ask_llm_for_remediation(full_q, context)
    if "error" in result:
        return result

    sql        = result.get("sql_query")
    confidence = result.get("confidence", 0)
    reason     = result.get("reason", "")

    if confidence >= 0.85:
        try:
            cur = db_conn.cursor()
            cur.execute(sql)
            db_conn.commit()
            return {
                "executed":  True,
                "confidence": confidence,
                "reason":    reason,
                "sql":        sql
            }
        except Exception as e:
            return {"executed": False, "error": str(e), "sql": sql, "confidence": confidence, "reason": reason}
    return {
        "executed": False,
        "message": "Confidence too low. Query not executed.",
        "confidence": confidence,
        "sql": sql,
        "reason": reason
    }

@app.post("/execute-sql")
def execute_sql(req: SQLRequest):
    try:
        cur = db_conn.cursor()
        cur.execute(req.sql)
        db_conn.commit()
        if req.sql.strip().lower().startswith("select"):
            cols = [d[0] for d in cur.description]
            rows = cur.fetchall()
            return {"columns": cols, "rows": rows}
        return {"status": "Success"}
    except Exception as e:
        return {"error": str(e)}

@app.get("/tables")
def list_tables():
    cur = db_conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
    return {"tables": [r[0] for r in cur.fetchall()]}

@app.get("/table/{table_name}")
def read_table(table_name: str):
    try:
        cur = db_conn.cursor()
        cur.execute(f"SELECT * FROM {table_name}")
        cols = [d[0] for d in cur.description]
        rows = cur.fetchall()
        return {"columns": cols, "rows": rows}
    except Exception as e:
        return {"error": str(e)}
